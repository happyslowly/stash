#!/usr/bin/env python

import os.path
import sys
import time
import pickle
import hashlib

__version__ = '0.0.1'


def usage():
    print("""
usage: stash <command> [<args>]

These are common stash commands:
    list        List what commands in the stash
    add         Add a command to stash
    search      Search a command by keywords
    update      Update a command by hash
    delete      Delete a command by hash
    exec        Execute a command by hash
    clean       Clean up stash
    """)


def get_console_width():
    try:
        import fcntl
        import termios
        import struct
        h, w, hp, wp = struct.unpack('HHHH', fcntl.ioctl(
            sys.stdin.fileno(), termios.TIOCGWINSZ, struct.pack('HHHH', 0, 0, 0, 0)))
        return w
    except:
        return 80


console_width = get_console_width()


class StashItem(object):
    def __init__(self, tag, command):
        self._command = command
        # take first 8 characters, it should be enough for this toy tool
        self._hash = hashlib.sha1(command.encode('utf-8')).hexdigest()[0:8]
        self._tag = tag
        self._time = int(time.time())

    @property
    def command(self):
        return self._command

    @command.setter
    def command(self, command):
        self._command = command

    @property
    def hash(self):
        return self._hash

    @property
    def tag(self):
        return self._tag

    @tag.setter
    def tag(self, tag):
        self._tag = tag

    @property
    def time(self):
        return _time

    def pprint(self):
        print('\033[1m' + '[' + self.tag + ' *' + self.hash + ']' + '\033[0m')
        print(self.command)


class Stash(object):
    def __init__(self):
        self.__stash_file = (os.environ['STASH_FILE'] if 'STASH_FILE' in os.environ else os.path.join(
            os.path.expanduser('~'), '.stash'))
        self.__stash = self._load()

    def _available(self):
        if not os.path.exists(self.__stash_file):
            return False
        stat_info = os.stat(self.__stash_file)
        return False if stat_info.st_size <= 0 else True

    def _load(self):
        if self._available():
            with open(self.__stash_file, 'rb') as f:
                return pickle.load(f)
        else:
            return {}

    def _save(self):
        with open(self.__stash_file, 'wb') as f:
            pickle.dump(self.__stash, f)

    def _get_input(self, prompt, defaults=''):
        import readline
        readline.set_startup_hook(lambda: readline.insert_text(defaults))
        try:
            return input(prompt)
        except NameError:
            return raw_input(prompt)
        finally:
            readline.set_startup_hook()

    def add(self, opt):
        tag = self._get_input('Tag: ')
        command = self._get_input('Command: ')
        item = StashItem(tag, command)
        self.__stash[item.hash] = item
        self._save()

    def clean(self, opt):
        os.remove(self.__stash_file)

    def list(self, opt):
        for i, item in enumerate(self.__stash.values()):
            if i > 0:
                print(console_width * '-')
            item.pprint()

    def search(self, opt):
        if len(opt) < 1:
            print('usage: stash search <hashcode>')
            return

        import re
        pattern = opt[0]
        i = 0
        for item in self.__stash.values():
            content = item.tag + item.command
            if re.search(pattern, content):
                if i > 0:
                    print(console_width * '-')
                item.pprint()

    def delete(self, opt):
        if len(opt) < 1:
            print('usage: stash delete <hashcode>')
            return

        hashcode = opt[0]
        if hashcode is not None:
            self.__stash.pop(hashcode)
            self._save()

    def update(self, opt):
        if len(opt) < 1:
            print('usage: stash update <hashcode>')
            return

        hashcode = opt[0]
        if hashcode is not None and hashcode in self.__stash:
            item = self.__stash[hashcode]
            item.command = self._get_input('Command: ', item.command)
            self._save()

    def exec(self, opt):
        if len(opt) < 1:
            print('usage: stash exec <hashcode>')
            return

        hashcode = opt[0]
        if hashcode is not None and hashcode in self.__stash:
            item = self.__stash[hashcode]
            try:
                command = self._get_input('Execute(Ctrl-C to cancel): ', item.command)
            except KeyboardInterrupt:
                print('\nCancelled')
            else:
                os.system(command)

    def start(self, args):
        if len(args) < 1:
            usage()
            return

        options = {
            'add': self.add,
            'list': self.list,
            'search': self.search,
            'exec': self.exec,
            'update': self.update,
            'delete': self.delete,
            'clean': self.clean,
        }
        command = args[0]
        opt = args[1:]

        if command in options:
            action = options[command]
            action(opt)
        else:
            usage()


if __name__ == '__main__':
    stash = Stash()
    stash.start(sys.argv[1:])
